{"title":"Stencil Goals and Objectives","description":"Stencil aims to combine the best concepts of the most popular frontend frameworks into a compile-time tool rather than run-time tool.","url":"/docs/goals-and-objectives","contributors":["adamdbradley"],"headings":[{"id":"stencil-goals-and-objectives","level":1,"text":"Stencil Goals And Objectives"},{"id":"web-standards","level":2,"text":"Web Standards"},{"id":"automatic-optimizations","level":2,"text":"Automatic Optimizations"},{"id":"future-friendly","level":2,"text":"Future-Friendly"},{"id":"run-time-performance","level":2,"text":"Run-time Performance"},{"id":"tiny-api","level":2,"text":"Tiny API"},{"id":"framework-features-during-development","level":2,"text":"Framework Features During Development"},{"id":"wide-browser-support","level":2,"text":"Wide Browser Support"}],"srcPath":"./src/docs/introduction/goals-and-objectives.md","content":"\n<h1 id=\"stencil-goals-and-objectives\">\n  \n  Stencil Goals And Objectives\n  \n</h1>\n<p>Stencil aims to combine the best concepts of the most popular frontend frameworks into a compile-time tool rather than run-time tool. It&#39;s important to stress that Stencil&#39;s goal is to <em>not</em> become or be seen as a &quot;framework&quot;, but rather our goal is to provide a great developer experience and tooling expected from a framework, while using web-standards within the browser at run-time. In many cases, Stencil can be used as a drop in replacement for traditional frontend frameworks given the capabilities now available in the browser, though using it as such is certainly not required.</p>\n\n<h2 id=\"web-standards\">\n  <a class=\"heading-link\" href=\"#web-standards\"><app-icon name=\"link\"></app-icon>\n  Web Standards\n  </a>\n</h2>\n<p>Components generated by Stencil in the end are built on top of web components, so they work in any major framework or with no framework at all. Additionally, other standards heavily relied on include ES Modules and dynamic imports which have proven to replace traditional bundlers which add unnecessary complexities and run-time JavaScript. By using web-standards, developers can learn and adopt a standard API documented across the world, rather than custom framework APIs that continue to change.</p>\n\n<h2 id=\"automatic-optimizations\">\n  <a class=\"heading-link\" href=\"#automatic-optimizations\"><app-icon name=\"link\"></app-icon>\n  Automatic Optimizations\n  </a>\n</h2>\n<p>There are countless optimizations and tweaks developers must do to improve performance of components and websites. With a compiler, Stencil is able to analyze component code as an input, and generate optimized components as an output.</p>\n\n<h2 id=\"future-friendly\">\n  <a class=\"heading-link\" href=\"#future-friendly\"><app-icon name=\"link\"></app-icon>\n  Future-Friendly\n  </a>\n</h2>\n<p>As the world of software development continues to evolve, so too can the compiler. Instead of requiring complete rewrites of components, the compiler can continue to make optimizations using the standard component model as the common input. The compiler allows developers to create future-friendly components, while still staying up-to-date on the latest optimizations without starting over again and again. Additionally, if something changes about any API, the compiler is able to make automatic adjustments and notify the developer exactly what needs to be updated.</p>\n\n<h2 id=\"run-time-performance\">\n  <a class=\"heading-link\" href=\"#run-time-performance\"><app-icon name=\"link\"></app-icon>\n  Run-time Performance\n  </a>\n</h2>\n<p>Instead of writing custom client-side JavaScript which every user needs to download and parse for the app to work, Stencil instead prefers to use the already amazing APIs built directly within the browser. These APIs include Custom Elements</p>\n\n<h2 id=\"tiny-api\">\n  <a class=\"heading-link\" href=\"#tiny-api\"><app-icon name=\"link\"></app-icon>\n  Tiny API\n  </a>\n</h2>\n<p>Stencil purposely does not come with a large custom API which needs to be learned and re-learned, but rather heavily relies on, you guessed it, web-standards. Again, our goal is to not create yet-another-framework, but rather provide tooling for developers to generate future-friendly components using APIs already baked within the browser. The smaller the API, the easier to learn, and the less that can be broken.</p>\n\n<h2 id=\"framework-features-during-development\">\n  <a class=\"heading-link\" href=\"#framework-features-during-development\"><app-icon name=\"link\"></app-icon>\n  Framework Features During Development\n  </a>\n</h2>\n<p>If you haven&#39;t noticed already we think web-standards are great and offer many benefits. While using web-standards without any structure is certainly possible, and there are actually many use-cases where this would be appropriate, we found that as apps and teams scale it quickly becomes difficult to manage. Developers often gravitate to frameworks because of their great tooling, defined structure, and ability to allow developers to build apps quickly. One of the largest goals of Stencil is to be that intersection of having great framework features and first-class tooling during development but generating future-proof web-standard code, rather than custom framework specific code.</p>\n\n<h2 id=\"wide-browser-support\">\n  <a class=\"heading-link\" href=\"#wide-browser-support\"><app-icon name=\"link\"></app-icon>\n  Wide Browser Support\n  </a>\n</h2>\n<p>For the small minority of browsers that do not support modern browser features and APIs, Stencil will automatically polyfill them on-demand. What this means is that for browsers that already support the feature natively, they will not have to download and parse any unnecessary JavaScript. The great news is that in today&#39;s web landscape, most modern APIs are already shipping for what Stencil requires. Out-of-the-box browser support includes IE11 and up.</p>\n"}